#!/bin/bash

# AI Proxy Log Database CLI Wrapper
# Convenient wrapper for logdb commands to reduce typing
#
# Usage examples:
#   ./scripts/logdb            # default: auto ingest + compaction
#   ./scripts/logdb auto       # explicit auto
#   ./scripts/logdb init
#   ./scripts/logdb ingest --from ./logs --since 2025-09-01 --to 2025-09-07
#   ./scripts/logdb fts build --since 2025-09-01 --to 2025-09-07
#   ./scripts/logdb bundle create --since 2025-09-01 --to 2025-09-07 --out backup.tgz
#   ./scripts/logdb bundle verify backup.tgz
#   ./scripts/logdb bundle transfer backup.tgz /dest/path/
#   ./scripts/logdb bundle import backup.tgz --dest ./logs/db
#   ./scripts/logdb dialogs assign --since 2025-09-01 --to 2025-09-07
#   ./scripts/logdb merge --from ./logs/db/2025/09 --to ./logs/db/monthly/2025-09.sqlite3

set -e  # Exit on any error

# Optional: disable bash history expansion to avoid bangs in JSON breaking commands
set +H 2>/dev/null || true

# Flag to control dotenv autoload (env or CLI)
LOGDB_AUTO_DOTENV_DEFAULT="1"
LOGDB_AUTO_DOTENV="${LOGDB_AUTO_DOTENV:-$LOGDB_AUTO_DOTENV_DEFAULT}"

# Parse optional global flag --no-dotenv (must come before command)
if [[ "${1:-}" == "--no-dotenv" ]]; then
    LOGDB_AUTO_DOTENV="0"
    shift
fi

# Load variables from .env without overriding already-set env vars
load_dotenv_if_enabled() {
    if [[ "$LOGDB_AUTO_DOTENV" != "1" ]]; then
        return 0
    fi
    if [[ -f .env ]]; then
        # Shell-safe parse of KEY=VALUE lines, ignore comments/blank lines
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Trim leading/trailing spaces
            line="${line#\ }"; line="${line%\ }"
            # Skip comments and blanks
            [[ -z "$line" || "$line" =~ ^# ]] && continue
            # Only simple KEY=VALUE (no export, no spaces around =)
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                val="${BASH_REMATCH[2]}"
                # Remove optional surrounding quotes for common cases
                if [[ "$val" =~ ^"(.*)"$ ]]; then val="${BASH_REMATCH[1]}"; fi
                if [[ "$val" =~ ^'(.*)'$ ]]; then val="${BASH_REMATCH[1]}"; fi
                # Export only if not already set in the environment
                if [[ -z "${!key+x}" ]]; then
                    export "$key"="$val"
                fi
            fi
        done < .env
    fi
}

# Colors for output (with fallback for terminals that don't support them)
if command -v tput >/dev/null 2>&1 && [[ $(tput colors 2>/dev/null || echo 0) -ge 8 ]] && [[ -t 1 ]]; then
    RED=$(tput setaf 1 2>/dev/null || echo '\033[0;31m')
    GREEN=$(tput setaf 2 2>/dev/null || echo '\033[0;32m')
    YELLOW=$(tput setaf 3 2>/dev/null || echo '\033[1;33m')
    BLUE=$(tput setaf 4 2>/dev/null || echo '\033[0;34m')
    NC=$(tput sgr0 2>/dev/null || echo '\033[0m')
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Function to get current env var value or default
get_env_value() {
    local var_name="$1"
    local default_value="$2"
    local current_value="${!var_name:-$default_value}"
    echo "$current_value"
}

# Function to print usage
usage() {
    cat << EOF
${BLUE}AI Proxy Log Database CLI Wrapper${NC}

${GREEN}Usage:${NC} $0 [command] [options]

${GREEN}Available commands:${NC}

  ${YELLOW}Core Commands:${NC}
    auto                 Ingest recent logs and compact completed weeks/months (default)
    init                 Initialize schema for a partition date
    ingest               Ingest structured logs into SQLite partitions
    merge                Merge partitions from a directory into a single SQLite file

  ${YELLOW}FTS Commands:${NC}
    fts build            Build FTS5 index for a date range
    fts drop             Drop FTS5 index table for a date range

  ${YELLOW}Bundle Commands:${NC}
    bundle create        Create a log bundle tar.gz
    bundle verify        Verify a log bundle
    bundle transfer      Transfer a bundle file with resume to destination path
    bundle import        Import a log bundle into destination dir

  ${YELLOW}Dialog Commands:${NC}
    dialogs assign       Assign dialog_id for a date range
    dialogs clear        Clear dialog_id values for a date range

${GREEN}Examples:${NC}
  $0                      # default auto
  $0 auto
  $0 init
  $0 ingest --from ./logs --since 2025-09-01 --to 2025-09-07
  $0 fts build --since 2025-09-01 --to 2025-09-07
  $0 bundle create --since 2025-09-01 --to 2025-09-07 --out backup.tgz
  $0 bundle verify backup.tgz
  $0 bundle transfer backup.tgz /dest/path/
  $0 bundle import backup.tgz --dest ./logs/db
  $0 dialogs assign --since 2025-09-01 --to 2025-09-07
  $0 merge --from ./logs/db/2025/09 --to ./logs/db/monthly/2025-09.sqlite3

${GREEN}Environment Variables (current values):${NC}
  LOGDB_ENABLED=$(get_env_value LOGDB_ENABLED false)                    # Enable log storage system
  LOGDB_FTS_ENABLED=$(get_env_value LOGDB_FTS_ENABLED false)            # Enable full-text search
  LOGDB_GROUPING_ENABLED=$(get_env_value LOGDB_GROUPING_ENABLED false)  # Enable dialog grouping
  LOGDB_PARTITION_GRANULARITY=$(get_env_value LOGDB_PARTITION_GRANULARITY daily)  # Partition granularity: daily|weekly
  LOGDB_BUNDLE_INCLUDE_RAW=$(get_env_value LOGDB_BUNDLE_INCLUDE_RAW false)  # Include raw logs in bundles
  LOGDB_IMPORT_PARALLELISM=$(get_env_value LOGDB_IMPORT_PARALLELISM 2)  # Concurrent file processing
  LOGDB_MEMORY_CAP_MB=$(get_env_value LOGDB_MEMORY_CAP_MB 256)          # Memory limit for processing (MB)

${GREEN}Help:${NC}
  $0 --help                            # Show this help
  $0 <command> --help                  # Show help for specific command
  ${YELLOW}Global flags:${NC}
  --no-dotenv                          # Do not auto-load .env (env vars take precedence by default)

EOF
}

# Function to check if we're in the right directory
check_project_dir() {
    if [[ ! -f "ai_proxy/main.py" ]] || [[ ! -f "ai_proxy/logdb/cli/__init__.py" ]]; then
        echo -e "${RED}Error: This script must be run from the AI Proxy project root directory${NC}"
        echo -e "${YELLOW}Current directory: $(pwd)${NC}"
        exit 1
    fi
}

# Function to run the command
run_command() {
    local cmd="$*"

    echo -e "${BLUE}Executing:${NC} python3 -m ai_proxy.logdb.cli $cmd"
    echo

    # Run the command
    if python3 -m ai_proxy.logdb.cli $cmd; then
        echo
        echo -e "${GREEN}✓ Command completed successfully${NC}"
    else
        local exit_code=$?
        echo
        echo -e "${RED}✗ Command failed with exit code $exit_code${NC}"
        return $exit_code
    fi
}

# Main script logic
main() {
    # Check if we're in the project directory
    check_project_dir

    # Auto-load .env (without clobbering existing env) unless disabled
    load_dotenv_if_enabled

    # Handle help
    if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
        usage
        exit 0
    fi

    # No args -> default to auto
    if [[ $# -eq 0 ]]; then
        run_command auto
        exit $?
    fi

    # Run the command
    run_command "$@"
}

# Run main function
main "$@"
